### 一、 程序生命周期与基础结构

Processing 程序主要由两个核心函数构成。这对应了您算法中的“预计算阶段”和“实时渲染阶段”。

#### 1. `void setup()`
*   **功能**：程序启动时仅执行一次。
*   **用途**：用于执行图像加载、边缘提取、路径排序、重采样、FFT 计算等耗时的预处理步骤。
*   **常用函数**：
    *   `size(int w, int h)`: 定义画布尺寸。
    *   `frameRate(int fps)`: 设置目标帧率（默认 60）。

#### 2. `void draw()`
*   **功能**：在 `setup()` 执行完毕后，无限循环执行。
*   **用途**：用于清空画布、计算当前时间 $t$ 的矢量位置、绘制圆与轨迹。
*   **常用函数**：
    *   `background(int rgb)`: 每帧调用以覆盖上一帧内容（实现动画效果）。

---

### 二、 图像处理与像素操作 (对应第一阶段)

Processing 使用一维数组存储二维图像数据，您需要手动处理坐标映射。

#### 1. 图像加载
```java
PImage img; // 定义图像对象

void setup() {
  img = loadImage("filename.jpg"); // 加载 data 文件夹下的图片
  img.resize(width, height);       // 可选：调整尺寸以匹配窗口
  img.loadPixels();                // 关键：将图像数据加载到 pixels[] 数组中
}
```

#### 2. 像素访问与灰度计算

图像数据存储在 `img.pixels[]` 数组中，长度为 $W \times H$。
*   **索引映射**：坐标 $(x, y)$ 对应的数组索引为 `int index = x + y * img.width`。
*   **亮度提取**：
```java
// 遍历图像（注意边界，Sobel算子通常忽略最外圈或做padding）
for (int y = 1; y < img.height - 1; y++) {
  for (int x = 1; x < img.width - 1; x++) {
    int index = x + y * img.width;
    
    // 获取颜色对象
    color c = img.pixels[index]; 
    
    // Processing 内置亮度计算函数 (等效于 0.299R + 0.587G + 0.114B)
    float b = brightness(c); 
    
    // 若需手动访问 RGB 分量
    float r = red(c);
    float g = green(c);
    // ...
  }
}
```

#### 3. 卷积实现的建议

由于需要访问邻域像素（如 $x-1, y+1$），直接通过索引偏移访问 `pixels[]` 即可。
*   $Y(x-1, y-1)$ 的索引为 `(x-1) + (y-1) * img.width`。
*   **注意**：Sobel 算子计算后的结果通常存储在一个新的二维数组或 `ArrayList` 中，不要直接修改原 `pixels[]`，否则会影响后续梯度的计算。

---

### 三、 数据结构与几何运算 (对应第二、三阶段)

Processing 提供了强大的向量类 `PVector` 和动态数组 `ArrayList`，这是处理有序路径的核心工具。

#### 1. 向量类 `PVector`

用于存储点坐标 $(x, y)$ 或复数（需自行约定 x 为实部, y 为虚部）。
```java
PVector v1 = new PVector(100, 200);
PVector v2 = new PVector(150, 250);

// 常用方法
float d = v1.dist(v2);        // 计算欧几里得距离 (用于最近邻搜索)
PVector v3 = PVector.sub(v2, v1); // 向量减法
float mag = v1.mag();         // 计算模长
```

#### 2. 动态数组 `ArrayList`

用于存储边缘点集，因为点数量未知。
```java
ArrayList<PVector> points = new ArrayList<PVector>();

// 添加点
points.add(new PVector(x, y));

// 获取点
PVector p = points.get(i);

// 移除点 (用于最近邻算法中从"未访问集合"移除)
points.remove(index);

// 获取长度
int len = points.size();
```

#### 3. 线性插值 (Lerp)
用于重采样阶段，计算两个点之间的中间点。
```java
// 计算 v1 和 v2 之间参数为 alpha (0.0 - 1.0) 的点
PVector result = PVector.lerp(v1, v2, alpha);
```

#### 4. 复数类定义 (Java)
Processing 没有内置 Complex 类，建议定义一个简单的内部类来处理 FFT 运算结果。
```java
class Complex {
  float re;
  float im;
  float freq;  // 物理频率 k
  float amp;   // 幅值
  float phase; // 相位
  
  Complex(float re, float im) {
    this.re = re;
    this.im = im;
  }
  
  // 用于计算幅值和相位
  void computePolar() {
    this.amp = sqrt(re*re + im*im);
    this.phase = atan2(im, re);
  }
}
```

---

### 四、 数学函数与 DFT 实现 (对应第四阶段)

您需要手动实现离散傅里叶变换的求和公式。Processing 基于 Java，支持标准 `Math` 库，但也封装了简化版函数。

*   **三角函数**：`sin(theta)`, `cos(theta)` (输入单位默认为弧度)。
*   **反三角函数**：`atan2(y, x)` (返回范围 $(-\pi, \pi]$，非常适合计算相位)。
*   **常数**：`TWO_PI` ($2\pi$), `PI` ($\pi$)。

**DFT 循环结构参考**：
```java
// 假设 signal 是重采样后的 PVector 列表 (x为实部, y为虚部)
// X 是存储频域系数 Complex 对象的数组
int N = signal.size();
Complex[] X = new Complex[N];

for (int k = 0; k < N; k++) {
  float sumRe = 0;
  float sumIm = 0;
  
  for (int n = 0; n < N; n++) {
    float angle = -TWO_PI * k * n / N; // 欧拉公式指数部分
    PVector xn = signal.get(n);
    
    // e^(ix) = cos(x) + i*sin(x)
    // 乘法分配律: (a+bi)(c+di) -> 实部与虚部的累加
    // 此处输入信号 x[n] 为复数形式 (xn.x + i*xn.y)
    // 具体展开: (xn.x + i*xn.y) * (cos + i*sin) 
    float c = cos(angle);
    float s = sin(angle);
    
    sumRe += xn.x * c - xn.y * s;
    sumIm += xn.x * s + xn.y * c;
  }
  
  X[k] = new Complex(sumRe/N, sumIm/N); // 包含归一化
  // 此处需处理频率 k 的映射 (0 到 N/2 为正频，N/2 到 N 为负频)
}
```

---

### 五、 排序与集合操作

为了实现“大圆带小圆”，需要对计算出的复数对象数组进行排序。Java 提供了 `Collections.sort` 或 `Arrays.sort`。

```java
import java.util.Collections;
import java.util.Comparator;

// 自定义比较器
class AmplitudeComparator implements Comparator<Complex> {
  public int compare(Complex c1, Complex c2) {
    // 降序排列 (返回负数表示 c1 排在 c2 前)
    if (c1.amp > c2.amp) return -1;
    else if (c1.amp < c2.amp) return 1;
    else return 0;
  }
}

// 在 setup 中调用
Arrays.sort(X, new AmplitudeComparator());
```

---

### 六、 渲染与坐标变换 (对应第五阶段)

这是 `draw()` 函数中的核心部分。

#### 1. 坐标系调整
Processing 默认原点 $(0,0)$ 在左上角，X轴向右，Y轴向下。这与数学常用的笛卡尔坐标系（Y轴向上）不同，但这通常只影响相位的符号，不影响形状闭合。
*   **居中**：通常需要将原点移动到屏幕中心。
```java
translate(width/2, height/2);
```

#### 2. 绘制形状
*   **绘制圆**：`ellipse(x, y, diameter, diameter)`。
    *   `noFill()`: 仅画轮廓。
    *   `stroke(255, 100)`: 设置线条颜色和透明度。
*   **绘制线条**：`line(x1, y1, x2, y2)`。

#### 3. 轨迹绘制 (Path Tracing)
由于每次重绘都会清空屏幕（`background()`），需要用一个列表存储历史位置来绘制连续的轨迹。
```java
ArrayList<PVector> path = new ArrayList<PVector>();

// 在 draw() 中计算完所有圆叠加后的末端点 v_end 后
path.add(v_end);

// 绘制轨迹
beginShape();
noFill();
stroke(255, 0, 0);
for (PVector v : path) {
  vertex(v.x, v.y);
}
endShape();

// 可选：限制轨迹长度，移除过旧的点以节省内存
if (path.size() > MAX_POINTS) path.remove(0);
```

---

### 七、 总结：Processing 实现该算法的结构全览

1.  **全局变量区**：
    *   `ArrayList<PVector> rawPoints`: 存储边缘检测后的点。
    *   `Complex[] fourierX`: 存储 DFT 结果。
    *   `float time`: 全局时间变量。
    *   `ArrayList<PVector> trail`: 绘制最终图像的轨迹点。

2.  **`setup()`**:
    *   `loadImage()` $\rightarrow$ `loadPixels()` $\rightarrow$ 卷积循环 $\rightarrow$ 填充 `rawPoints`。
    *   执行贪心算法（最近邻）对 `rawPoints` 排序。
    *   执行重采样（插值）生成 $M$ 个均匀点。
    *   执行 DFT 循环生成 `fourierX`。
    *   执行 `Arrays.sort` 对频谱排序。

3.  **`draw()`**:
    *   `background(0)`。
    *   `translate(width/2, height/2)`。
    *   初始化当前矢量位置 `float x = 0, y = 0`。
    *   **循环遍历** `fourierX` 数组：
        *   获取 $freq, amp, phase$。
        *   计算当前圆的结束点 `prevX = x`, `prevY = y`。
        *   更新 `x += ...`, `y += ...` (利用 `cos`, `sin`)。
        *   `ellipse(...)` 绘制圆。
        *   `line(...)` 绘制半径。
    *   将最终 $(x, y)$ 加入 `trail`。
    *   `beginShape()` 绘制 `trail`。
    *   更新 `time += dt`。
    *   处理 `time > TWO_PI` 的重置逻辑（如果需要清空轨迹）。

这份文档涵盖了您在 Processing 中实现该数学可视化所需的所有 API 和逻辑映射。您现在可以开始编写代码了。